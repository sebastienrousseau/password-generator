<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/PasswordGeneratorFactory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/PasswordGeneratorFactory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Copyright Â© 2022-2024 Password Generator. All rights reserved.
// SPDX-License-Identifier: Apache-2.0 OR MIT

import { PASSWORD_ERRORS } from "../errors.js";
import { isValidPasswordType } from "../config.js";

/**
 * Factory class for dynamically loading and managing password generator modules.
 *
 * Handles dynamic module loading with comprehensive error handling, module validation,
 * and proper async/sync abstraction for different password generation algorithms.
 *
 * @class PasswordGeneratorFactory
 */
export class PasswordGeneratorFactory {
  /**
   * @private
   * @type {Map&lt;string, Object>} Cache of loaded generator modules
   */
  static #moduleCache = new Map();

  /**
   * @private
   * @type {Map&lt;string, string>} Type to module path mapping
   */
  static #modulePathMap = new Map([
    ["strong", "../lib/strong-password.js"],
    ["base64", "../lib/base64-password.js"],
    ["memorable", "../lib/memorable-password.js"],
  ]);

  /**
   * @private
   * @type {Set&lt;string>} Types that require async handling
   */
  static #asyncTypes = new Set(["memorable"]);

  /**
   * Validates that a module has the required interface.
   *
   * @private
   * @param {Object} module - The loaded module to validate
   * @param {string} type - The password type for error reporting
   * @throws {Error} If module interface is invalid
   */
  /* c8 ignore start - Defensive validation for malformed modules */
  static #validateModuleInterface(module, type) {
    if (!module || typeof module !== "object") {
      throw new Error(`Invalid module for type "${type}": module must be an object`);
    }

    if (typeof module.generatePassword !== "function") {
      throw new Error(`Invalid module for type "${type}": missing generatePassword function`);
    }

    // Additional validation could be added here for specific function signatures
    // if needed for stricter type checking
  }
  /* c8 ignore stop */

  /**
   * Validates password generation configuration.
   *
   * @private
   * @param {Object} config - Configuration object to validate
   * @throws {Error} If configuration is invalid
   */
  static #validateConfig(config) {
    if (!config || typeof config !== "object") {
      throw new Error("Configuration must be an object");
    }

    if (!config.type) {
      throw new Error(PASSWORD_ERRORS.TYPE_REQUIRED);
    }

    if (!isValidPasswordType(config.type)) {
      throw new Error(PASSWORD_ERRORS.UNKNOWN_TYPE(config.type));
    }

    // Type-specific validation
    if (["strong", "base64"].includes(config.type)) {
      if (typeof config.length !== "number" || config.length &lt;= 0) {
        throw new RangeError(
          `Type "${config.type}" requires a positive integer "length" parameter`
        );
      }
    }

    if (typeof config.iteration !== "number" || config.iteration &lt;= 0) {
      throw new RangeError("Configuration requires a positive integer \"iteration\" parameter");
    }

    if (typeof config.separator !== "string") {
      throw new Error("Configuration requires a string \"separator\" parameter");
    }
  }

  /**
   * Dynamically loads a password generator module with caching.
   *
   * @private
   * @param {string} type - The password type to load module for
   * @returns {Promise&lt;Object>} The loaded generator module
   * @throws {Error} If module loading fails or module is invalid
   */
  static async #loadModule(type) {
    // Check cache first
    if (this.#moduleCache.has(type)) {
      return this.#moduleCache.get(type);
    }

    const modulePath = this.#modulePathMap.get(type);
    /* c8 ignore start - Defensive check for unmapped types */
    if (!modulePath) {
      throw new Error(PASSWORD_ERRORS.UNKNOWN_TYPE(type));
    }
    /* c8 ignore stop */

    try {
      const module = await import(modulePath);

      // Validate the loaded module
      this.#validateModuleInterface(module, type);

      // Cache the module
      this.#moduleCache.set(type, module);

      return module;
      /* c8 ignore start - Error handling for various import failures */
    } catch (error) {
      // Handle different types of import errors
      if (error.code === "ERR_MODULE_NOT_FOUND") {
        throw new Error(`Password generator module not found for type "${type}"`);
      }

      if (error.code === "ERR_INVALID_MODULE_SPECIFIER") {
        throw new Error(`Invalid module specifier for type "${type}"`);
      }

      // Handle ES module syntax errors
      if (error.name === "SyntaxError") {
        throw new Error(
          `Syntax error in password generator module for type "${type}": ${error.message}`
        );
      }

      // Re-throw validation errors and other custom errors
      if (error.message.includes("Invalid module for type")) {
        throw error;
      }

      // Generic import error
      throw new Error(
        `Failed to load password generator module for type "${type}": ${error.message}`
      );
    }
    /* c8 ignore stop */
  }

  /**
   * Creates a password generator for the specified type.
   *
   * @param {string} type - The type of password generator to create
   * @returns {Promise&lt;Object>} Password generator instance with generate method
   * @throws {Error} If type is invalid or module loading fails
   */
  static async createGenerator(type) {
    if (!type) {
      throw new Error(PASSWORD_ERRORS.TYPE_REQUIRED);
    }

    if (!isValidPasswordType(type)) {
      throw new Error(PASSWORD_ERRORS.UNKNOWN_TYPE(type));
    }

    try {
      const module = await this.#loadModule(type);
      const isAsync = this.#asyncTypes.has(type);

      return {
        type,
        isAsync,

        /**
         * Generates a password using the loaded module.
         *
         * @param {Object} config - Password generation configuration
         * @returns {Promise&lt;string>} Generated password
         */
        async generate(config) {
          // Validate configuration
          PasswordGeneratorFactory.#validateConfig({ ...config, type });

          try {
            // Call the module's generatePassword function
            const result = module.generatePassword(config);

            // Handle both sync and async modules uniformly
            return isAsync ? await result : result;
            /* c8 ignore start - Error wrapper for generation failures */
          } catch (error) {
            // Wrap generation errors with context
            throw new Error(`Password generation failed for type "${type}": ${error.message}`);
          }
          /* c8 ignore stop */
        },
      };
      /* c8 ignore start - Error wrapper for factory failures */
    } catch (error) {
      // Re-throw with factory context if not already wrapped
      if (!error.message.includes("Failed to load") &amp;&amp; !error.message.includes("Invalid module")) {
        throw new Error(`Failed to create password generator for type "${type}": ${error.message}`);
      }
      throw error;
    }
    /* c8 ignore stop */
  }

  /**
   * Generates a password directly using the factory (convenience method).
   *
   * @param {Object} config - Password generation configuration
   * @param {string} config.type - The type of password to generate
   * @param {number} [config.length] - Length of each password chunk (for strong/base64 types)
   * @param {number} config.iteration - Number of password chunks or words
   * @param {string} config.separator - Separator between password chunks
   * @returns {Promise&lt;string>} Generated password
   * @throws {Error} If generation fails
   */
  static async generate(config) {
    this.#validateConfig(config);

    const generator = await this.createGenerator(config.type);
    return generator.generate(config);
  }

  /**
   * Checks if a password type is supported.
   *
   * @param {string} type - The password type to check
   * @returns {boolean} True if type is supported, false otherwise
   */
  static isSupported(type) {
    return isValidPasswordType(type) &amp;&amp; this.#modulePathMap.has(type);
  }

  /**
   * Gets all supported password types.
   *
   * @returns {string[]} Array of supported password types
   */
  static getSupportedTypes() {
    return Array.from(this.#modulePathMap.keys());
  }

  /**
   * Clears the module cache (useful for testing or hot reloading).
   *
   * @static
   */
  static clearCache() {
    this.#moduleCache.clear();
  }

  /**
   * Registers a new password generator type with its module path.
   *
   * @param {string} type - The password type identifier
   * @param {string} modulePath - The path to the generator module
   * @param {boolean} [isAsync=false] - Whether the module's generatePassword is async
   * @throws {Error} If type is already registered or parameters are invalid
   */
  static registerType(type, modulePath, isAsync = false) {
    if (!type || typeof type !== "string") {
      throw new Error("Type must be a non-empty string");
    }

    if (!modulePath || typeof modulePath !== "string") {
      throw new Error("Module path must be a non-empty string");
    }

    if (this.#modulePathMap.has(type)) {
      throw new Error(`Password type "${type}" is already registered`);
    }

    this.#modulePathMap.set(type, modulePath);

    if (isAsync) {
      this.#asyncTypes.add(type);
    }
  }

  /**
   * Unregisters a password generator type.
   *
   * @param {string} type - The password type to unregister
   * @returns {boolean} True if type was unregistered, false if not found
   */
  static unregisterType(type) {
    if (!this.#modulePathMap.has(type)) {
      return false;
    }

    this.#modulePathMap.delete(type);
    this.#asyncTypes.delete(type);
    this.#moduleCache.delete(type);

    return true;
  }
}

export default PasswordGeneratorFactory;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-config.html">config</a></li><li><a href="module-constants.html">constants</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-security-audit.html">security-audit</a></li><li><a href="module-services_audit-service.html">services/audit-service</a></li><li><a href="module-services_cli-service.html">services/cli-service</a></li><li><a href="module-services_config-service.html">services/config-service</a></li><li><a href="module-services_password-service.html">services/password-service</a></li><li><a href="module-strings.html">strings</a></li></ul><h3>Classes</h3><ul><li><a href="CLIController.html">CLIController</a></li><li><a href="CommandLearningPresenter.html">CommandLearningPresenter</a></li><li><a href="ConfigurationService.html">ConfigurationService</a></li><li><a href="OnboardingFlow.html">OnboardingFlow</a></li><li><a href="PasswordGeneratorFactory.html">PasswordGeneratorFactory</a></li><li><a href="PasswordGeneratorOrchestrator.html">PasswordGeneratorOrchestrator</a></li></ul><h3>Global</h3><ul><li><a href="global.html#PasswordGenerator">PasswordGenerator</a></li><li><a href="global.html#createCLIController">createCLIController</a></li><li><a href="global.html#dictionaryCache">dictionaryCache</a></li><li><a href="global.html#generate">generate</a></li><li><a href="global.html#generateBase64Chunk">generateBase64Chunk</a></li><li><a href="global.html#generatePassword">generatePassword</a></li><li><a href="global.html#generateRandomBase64">generateRandomBase64</a></li><li><a href="global.html#isFirstRun">isFirstRun</a></li><li><a href="global.html#loadDictionary">loadDictionary</a></li><li><a href="global.html#randomConsonant">randomConsonant</a></li><li><a href="global.html#randomNumber">randomNumber</a></li><li><a href="global.html#randomSyllable">randomSyllable</a></li><li><a href="global.html#randomVowel">randomVowel</a></li><li><a href="global.html#splitString">splitString</a></li><li><a href="global.html#startOnboarding">startOnboarding</a></li><li><a href="global.html#validatePositiveInteger">validatePositiveInteger</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Fri Feb 06 2026 23:45:51 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
